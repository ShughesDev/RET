# -*- coding: utf-8 -*-
""".

Continuous Canvas Rendering
========================

Module for visualizing model objects in a continuous space.

"""
from collections import defaultdict

from mesa.visualization.BackgroundImageMethods import find_background_image_path
from mesa.visualization.ModularVisualization import VisualizationElement


class CanvasContinuous(VisualizationElement):
    """.

    A CanvasContinuous object uses a user-provided portrayal method to generate a
    portrayal for each object. A portrayal is a JSON-ready dictionary which
    tells the relevant JavaScript code (ContiunuousDraw.js) where to draw what shape.

    The render method returns a dictionary with values as lists of portrayals
    to draw. Portrayals themselves are generated by the user-provided
    portrayal_method, which accepts an object as an input and produces a portrayal
    of it.

    A portrayal as a dictionary with the following structure:
        "Shape": Can be either "circle", "rect" or a custom image.
            For Circles:
                "r": The radius, in pixels.
            For Rectangles:
                "w", "h": The width and height of the rectangle, which are in
                          fractions of space width and height.
             For an image:
                The image must be placed in the same directory from which the
                server is launched. An image has the attributes "x", "y",
                "scale", "text" and "text_color".
        "Color": The color to draw the shape in; needs to be a valid HTML
                 color, e.g."Red" or "#AA08F8"
        "Filled": either "true" or "false", and determines whether the shape is
                  filled or not.
        "text": The text to be inscribed inside the Shape. Normally useful for
                showing the unique_id of the agent.
        "text_color": The color to draw the inscribed text. Should be given in
                      conjunction of "text" property.


    Attributes:
        portrayal_method: Function which generates portrayals from objects, as
                          described above.
        canvas_height, canvas_width: Size, in pixels, of the space visualization
                                     to draw on the client.
        template: "modular_template.html" stores the module's HTML template.

    """

    package_includes = [
        "ContinuousDraw.js",
        "CanvasContinuousModule.js",
        "InteractionHandlerCont.js",
    ]

    def __init__(
        self,
        portrayal_method,
        canvas_width=500,
        canvas_height=500,
        canvas_background_file=None,
    ):
        """Instantiate a new CanvasContinuous.

        Args:
            portrayal_method: function to convert each object on the canvas to
                              a portrayal, as described above.
            canvas_height:,
            canvas_width: Size of the canvas to draw in the
                                         client, in pixels. (default: 500x500)
            canvas_background_file: Absolute path to a background image file.

        """
        self.canvas_background_path = find_background_image_path(
            canvas_width, canvas_height, canvas_background_file
        )
        self.portrayal_method = portrayal_method
        self.canvas_height = canvas_height
        self.canvas_width = canvas_width

        new_element = "new CanvasContinuousModule({}, {}, {})".format(
            self.canvas_width,
            self.canvas_height,
            "'" + self.canvas_background_path + "'",
        )
        self.js_code = "elements.push(" + new_element + ");"

    def render(self, model):
        """."""
        space_state = defaultdict(list)
        for obj in model.schedule.agents:
            portrayal = self.portrayal_method(obj)
            if portrayal:
                x = obj.pos[0]
                y = obj.pos[1]
                x = (x - model.space.x_min) / (model.space.x_max - model.space.x_min)
                y = (y - model.space.y_min) / (model.space.y_max - model.space.y_min)
                portrayal["x"] = x
                portrayal["y"] = y
                space_state[portrayal["Layer"]].append(portrayal)
        return space_state
